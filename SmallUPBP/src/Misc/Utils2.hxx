/*
 * Copyright (C) 2014, Petr Vevoda, Martin Sik (http://cgg.mff.cuni.cz/~sik/), 
 * Tomas Davidovic (http://www.davidovic.cz), Iliyan Georgiev (http://www.iliyan.com/), 
 * Jaroslav Krivanek (http://cgg.mff.cuni.cz/~jaroslav/)
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * (The above is MIT License: http://en.wikipedia.origin/wiki/MIT_License)
 */

#ifndef __UTILS2_HXX__
#define __UTILS2_HXX__

#include <vector>
#include <cmath>
#include <cstdint>
#include <algorithm>

#include "../Structs/Rgb.hxx"

//////////////////////////////////////////////////////////////////////////
// Cosine lobe hemisphere sampling

/**
 * @brief	Generates a random direction via cosine lobe hemisphere sampling.
 *
 * @param	aSamples	 	Random samples.
 * @param	aPower		 	The power.
 * @param [in,out]	oPdfW	If non-null, the solid angle PDF.
 *
 * @return	Generated direction.
 */
inline Dir SamplePowerCosHemisphereW(
    const Vec2f  &aSamples,
    const float  aPower,
    float        *oPdfW)
{
    const float term1 = 2.f * PI_F * aSamples.get(0);
    const float term2 = std::pow(aSamples.get(1), 1.f / (aPower + 1.f));
    const float term3 = std::sqrt(1.f - term2 * term2);

    if(oPdfW)
    {
        *oPdfW = (aPower + 1.f) * std::pow(term2, aPower) * (0.5f * INV_PI_F);
    }

    return Dir(
        std::cos(term1) * term3,
        std::sin(term1) * term3,
        term2);
}

/**
 * @brief	Solid angle PDF of a direction generated by cosine lobe hemisphere sampling.
 *
 * @param	aNormal   	The normal (direction of the lobe).
 * @param	aDirection	The direction to get the PDF for.
 * @param	aPower	  	The power.
 *
 * @return	PDF of the direction.
 */
inline float PowerCosHemispherePdfW(
    const Dir  &aNormal,
    const Dir  &aDirection,
    const float  aPower)
{
    const float cosTheta = std::max(0.f, dot(aNormal, aDirection));

    return (aPower + 1.f) * std::pow(cosTheta, aPower) * (INV_PI_F * 0.5f);
}

//////////////////////////////////////////////////////////////////////////
// Disc sampling

/**
 * @brief	Samples a concentric unit disc.
 *
 * @param	aSamples	Random samples.
 *
 * @return	Generated position on the disc.
 */
inline Vec2f SampleConcentricDisc(
    const Vec2f &aSamples)
{
    float phi, r;

    float a = 2*aSamples.get(0) - 1;   /* (a,b) is now on [-1,1]^2 */
    float b = 2*aSamples.get(1) - 1;

    if(a > -b)      /* region 1 or 2 */
    {
        if(a > b)   /* region 1, also |a| > |b| */
        {
            r = a;
            phi = (PI_F/4.f) * (b/a);
        }
        else        /* region 2, also |b| > |a| */
        {
            r = b;
            phi = (PI_F/4.f) * (2.f - (a/b));
        }
    }
    else            /* region 3 or 4 */
    {
        if(a < b)   /* region 3, also |a| >= |b|, a != 0 */
        {
            r = -a;
            phi = (PI_F/4.f) * (4.f + (b/a));
        }
        else        /* region 4, |b| >= |a|, but a==0 and b==0 could occur. */
        {
            r = -b;

            if (b != 0)
                phi = (PI_F/4.f) * (6.f - (a/b));
            else
                phi = 0;
        }
    }

    Vec2f res;
    res.get(0) = r * std::cos(phi);
    res.get(1) = r * std::sin(phi);
    return res;
}

/**
 * @brief	Area PDF of sampling a position on a concentric unit disc.
 *
 * @return	1/Pi.
 */
inline float ConcentricDiscPdfA()
{
    return INV_PI_F;
}

//////////////////////////////////////////////////////////////////////////
/// Cosine hemisphere sampling

/**
 * @brief	Samples direction in the upper hemisphere with cosine-proportional PDF.
 *
 * @param	aSamples	 	Random samples.
 * @param [in,out]	oPdfW	If non-null, the solid angle PDF.
 *
 * @return	Generated direction.
 */
inline Dir SampleCosHemisphereW(
    const Vec2f  &aSamples,
    float        *oPdfW)
{
    const float term1 = 2.f * PI_F * aSamples.get(0);
    const float term2 = std::sqrt(1.f - aSamples.get(1));

    const Dir ret(
        std::cos(term1) * term2,
        std::sin(term1) * term2,
        std::sqrt(aSamples.get(1)));

    if(oPdfW)
    {
        *oPdfW = ret.z() * INV_PI_F;
    }

    return ret;
}

/**
 * @brief	Solid angle PDF of a direction generated by cosine hemisphere sampling.
 *
 * @param	aNormal   	The normal (direction of the lobe).
 * @param	aDirection	The direction to get the PDF for.
 *
 * @return	PDF of the direction.
 */
inline float CosHemispherePdfW(
    const Dir  &aNormal,
    const Dir  &aDirection)
{
    return std::max(0.f, dot(aNormal, aDirection)) * INV_PI_F;
}

/**
 * @brief	Uniformly samples position on a triangle.
 *
 * @param	aSamples	Random samples.
 *
 * @return	Generated position in barycentric coordinates.
 */
inline Vec2f SampleUniformTriangle(const Vec2f &aSamples)
{
    const float term = std::sqrt(aSamples.get(0));

    return Vec2f(1.f - term, aSamples.get(1) * term);
}

//////////////////////////////////////////////////////////////////////////
// Sphere sampling

/**
 * @brief	Uniformly samples direction on a unit sphere.
 *
 * @param	aSamples	  	Random samples.
 * @param [in,out]	oPdfSA	If non-null, the solid angle PDF.
 *
 * @return	Generated direction.
 */
inline Dir SampleUniformSphereW(
    const Vec2f  &aSamples,
    float        *oPdfSA)
{
    const float term1 = 2.f * PI_F * aSamples.get(0);
    const float term2 = 2.f * std::sqrt(aSamples.get(1) - aSamples.get(1) * aSamples.get(1));

    const Dir ret(
        std::cos(term1) * term2,
        std::sin(term1) * term2,
        1.f - 2.f * aSamples.get(1));

    if(oPdfSA)
    {
        *oPdfSA = INV_PI_F * 0.25f;
    }

    return ret;
}

/**
 * @brief	Solid angle PDF of a direction generated by uniform sphere sampling.
 *
 * @return	PDF of the direction.
 */
inline float UniformSpherePdfW()
{
    return INV_PI_F * 0.25f;
}

//////////////////////////////////////////////////////////////////////////
// Utilities for converting PDF between Area (A) and Solid angle (W)
// WtoA = PdfW * cosine / distance_squared
// AtoW = PdfA * distance_squared / cosine

/**
 * @brief	Solid angle PDF to area.
 *
 * @param	aPdfW	 	Solid angle PDF.
 * @param	aDist	 	Distance from here to there.
 * @param	aCosThere	Cosine there.
 *
 * @return	Area PDF.
 */
inline float PdfWtoA(
    const float aPdfW,
    const float aDist,
    const float aCosThere)
{
    return aPdfW * std::abs(aCosThere) / Utils::sqr(aDist);
}

/**
 * @brief	Area PDF to solid angle.
 *
 * @param	aPdfW	 	Area PDF.
 * @param	aDist	 	Distance from here to there.
 * @param	aCosThere	Cosine there.
 *
 * @return	Solid angle PDF.
 */
inline float PdfAtoW(
    const float aPdfA,
    const float aDist,
    const float aCosThere)
{
    return aPdfA * Utils::sqr(aDist) / std::abs(aCosThere);
}

//////////////////////////////////////////////////////////////////////////
// Misc

/**
 * @brief	Converts non-negative float to RGB color.
 * 			
 * 			Takes the given value x and converts (x, 1, 1) from HSV to RGB.
 *
 * @param	aValue	The float to convert.
 *
 * @return	Resulting RGB.
 */
inline Rgb float2color(const float aValue)
{
	float h = (1.0f - aValue) * 4;
	float x = 1.0f - std::abs(std::fmod(h, 2.0f) - 1.0f);

	if (h < 1)
		return Rgb(1.0f, x, 0.0f);
	else if (h < 2)
		return Rgb(x, 1.0f, 0.0f);
	else if (h < 3)
		return Rgb(0.0f, 1.0f, x);
	else
		return Rgb(0.0f, x, 1.0f);
}

/**
 * @brief	Computes sRGB luminance.
 *
 * @param	aRGB	RGB value to compute the luminance for.
 *
 * @return  The luminance.
 */
inline float Luminance(const Rgb& aRGB)
{
    return 0.212671f * aRGB.r() +
        0.715160f * aRGB.g() +
        0.072169f * aRGB.b();
}

/**
 * @brief	Computes Fresnel coefficient for dielectric.
 *
 * @param	aCosInc	Cosine of angle of the incoming direction.
 * @param	mIOR   	Relative IOR of the boundary.
 *
 * @return	Fresnel coefficient.
 */
inline float FresnelDielectric(
    float aCosInc,
    float mIOR)
{
    if(mIOR < 0)
        return 1.f;

    float etaIncOverEtaTrans = mIOR;

    if(aCosInc < 0.f) aCosInc = -aCosInc;

    const float sinTrans2 = Utils::sqr(etaIncOverEtaTrans) * (1.f - Utils::sqr(aCosInc));
    const float cosTrans = std::sqrt(std::max(0.f, 1.f - sinTrans2));

    const float term1 = etaIncOverEtaTrans * cosTrans;
    const float rParallel =
        (aCosInc - term1) / (aCosInc + term1);

    const float term2 = etaIncOverEtaTrans * aCosInc;
    const float rPerpendicular =
        (term2 - cosTrans) / (term2 + cosTrans);

    return 0.5f * (Utils::sqr(rParallel) + Utils::sqr(rPerpendicular));
}

/**
 * @brief	Reflects direction through (0,0,1).
 *
 * @param	aVector	The direction to reflect.
 *
 * @return	The reflected direction.
 */
inline Dir ReflectLocal(const Dir& aVector)
{
    return Dir(-aVector.x(), -aVector.y(), aVector.z());
}

#endif //__UTILS_HXX__